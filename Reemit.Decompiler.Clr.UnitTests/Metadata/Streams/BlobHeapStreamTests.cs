using Reemit.Common;
using Reemit.Decompiler.Clr.Metadata;
using Reemit.Decompiler.Clr.Metadata.Streams;

namespace Reemit.Decompiler.Clr.UnitTests.Metadata.Streams;

public class BlobHeapStreamTests
{
    [Theory]
    [InlineData([new byte[] { 0x04 }, 4])]
    [InlineData([new byte[] { 0x80, 0x98 }, 152])]
    [InlineData([new byte[] { 0xC0, 0x0, 0xD2, 0xF7 }, 54007])]
    public void CreateReader_Called_CreatesReaderWithCorrectLength(byte[] lengthEncodingBytes, int expectedLength)
    {
        // Arrange
        var blobHeapStream = CreateBlobHeapStream(lengthEncodingBytes);
        
        // Act
        var blobReader = blobHeapStream.CreateBlobReader(0);
        
        // Assert
        Assert.Equal(expectedLength, blobReader.Length);
    }

    [Theory]
    [InlineData([new byte[]
    {
        // junk
        0x00, 0x00,
        
        // length
        0x04,
        
        // blob data
        0x08, 0x05, 0x20
    }, 2, new byte[] { 0x08, 0x05, 0x20 }])]
    public void Read_BlobLengthEncodedInSingleByte_ReadsBlobIntoByteArray(byte[] heapStreamBytes, uint offset, byte[] expectedResult)
    {
        // Arrange
        var blobHeapStream = CreateBlobHeapStream(heapStreamBytes);
        
        // Act
        var blobBytes = blobHeapStream.Read(offset);
        
        // Assert
        Assert.Equal(expectedResult, blobBytes);
    }
    
    [Theory]
    [InlineData([new byte[]
    {
        // junk
        0x00, 0x00, 0x00,
        
        // length
        0x80, 0x98,
        
        // blob data
        0x20, 0x0B, 0x1D, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12,
        0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15,
        0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13,
        0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01,
        0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81,
        0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15,
        0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01,
        0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02,
        0x13, 0x00, 0x15, 0x12, 0x6D, 0x01
    }, 3, new byte[]
    {
        0x20, 0x0B, 0x1D, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12,
        0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15,
        0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13,
        0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01,
        0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81,
        0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15,
        0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01,
        0x15, 0x12, 0x81, 0x1C, 0x02, 0x13, 0x00, 0x15, 0x12, 0x6D, 0x01, 0x13, 0x01, 0x15, 0x12, 0x81, 0x1C, 0x02,
        0x13, 0x00, 0x15, 0x12, 0x6D, 0x01
    }])]
    public void Read_BlobLengthEncodedInTwoBytes_ReadsBlobIntoByteArray(byte[] heapStreamBytes, uint offset, byte[] expectedResult)
    {
        // Arrange
        var blobHeapStream = CreateBlobHeapStream(heapStreamBytes);
        
        // Act
        var blobBytes = blobHeapStream.Read(offset);
        
        // Assert
        Assert.Equal(expectedResult, blobBytes);
    }
    
    [Fact]
    public void Read_BlobLengthEncodedInFourBytes_ReadsBlobIntoByteArray()
    {
        // Arrange
        var heapStreamBytes = File.ReadAllBytes("Resources/blob_with_length_encoded_in_4_bytes.bin");
        // the expected result are blob bytes, which are located right after the bytes encoding blob length
        var expectedResult = heapStreamBytes[4..];
        var blobHeapStream = CreateBlobHeapStream(heapStreamBytes);
        
        // Act
        var blobBytes = blobHeapStream.Read(0);
        
        // Assert
        Assert.Equal(expectedResult, blobBytes);
    }
    
    private static BlobHeapStream CreateBlobHeapStream(byte[] heapStreamBytes)
    {
        var ms = new MemoryStream(heapStreamBytes);
        var reader = new SharedReader(0, new BinaryReader(ms));
        return new BlobHeapStream(reader, new StreamHeader(0u, (uint)heapStreamBytes.Length, string.Empty));
    }
}